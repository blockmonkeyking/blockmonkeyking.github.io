System.register(["../main-legacy.js"],function(e,t){"use strict";var a,r,s,n,o,c,i,u,d,l,f,h,p,w,m,y,g,b,k,x,R,L,M,O,P;return{setters:[e=>{a=e.s,r=e.t,s=e.f,n=e.A,o=e.d,c=e.g,i=e.a,u=e.b,d=e.e,l=e.c,f=e.h,h=e.i,p=e.I,w=e.j,m=e.k,y=e.l,g=e.m,b=e.B,k=e.n,x=e.o,R=e.p,L=e.q,M=e.r,O=e.H,P=e.u}],execute:function(){function t(e){const{abi:t,data:c}=e,i=a(c,0,4),u=t.find(e=>"function"===e.type&&i===r(s(e)));if(!u)throw new n(i,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:u.name,args:"inputs"in u&&u.inputs&&u.inputs.length>0?o(u.inputs,a(c,4)):void 0}}e({ccipRequest:D,offchainLookup:async function(e,{blockNumber:t,blockTag:a,data:r,to:s}){const{args:n}=R({data:r,abi:[A]}),[o,c,i,u,l]=n,{ccipRead:f}=e,h=f&&"function"==typeof f?.request?f.request:D;try{if(!function(e,t){if(!y(e,{strict:!1}))throw new g({address:e});if(!y(t,{strict:!1}))throw new g({address:t});return e.toLowerCase()===t.toLowerCase()}(s,o))throw new v({sender:o,to:s});const r=c.includes(N)?await T({data:i,ccipRequest:h}):await h({data:i,sender:o,urls:c}),{data:n}=await L(e,{blockNumber:t,blockTag:a,data:M([u,d([{type:"bytes"},{type:"bytes"}],[r,l])]),to:s});return n}catch(e){throw new $({callbackSelector:u,cause:e,data:r,extraData:l,sender:o,urls:c})}}});const E="/docs/contract/encodeErrorResult";function S(e){const{abi:t,errorName:a,args:n}=e;let o=t[0];if(a){const e=c({abi:t,args:n,name:a});if(!e)throw new i(a,{docsPath:E});o=e}if("error"!==o.type)throw new i(void 0,{docsPath:E});const f=s(o),h=r(f);let p="0x";if(n&&n.length>0){if(!o.inputs)throw new u(o.name,{docsPath:E});p=d(o.inputs,n)}return l([h,p])}const q="/docs/contract/encodeFunctionResult",N="x-batch-gateway:true";async function T(e){const{data:a,ccipRequest:r}=e,{args:[s]}=t({abi:w,data:a}),n=[],o=[];return await Promise.all(s.map(async(e,t)=>{try{o[t]=e.urls.includes(N)?await T({data:e.data,ccipRequest:r}):await r(e),n[t]=!1}catch(e){n[t]=!0,o[t]=function(e){return"HttpRequestError"===e.name&&e.status?S({abi:w,errorName:"HttpError",args:[e.status,e.shortMessage]}):S({abi:[m],errorName:"Error",args:["shortMessage"in e?e.shortMessage:e.message]})}(e)}})),function(e){const{abi:t,functionName:a,result:r}=e;let s=t[0];if(a){const e=c({abi:t,name:a});if(!e)throw new f(a,{docsPath:q});s=e}if("function"!==s.type)throw new f(void 0,{docsPath:q});if(!s.outputs)throw new h(s.name,{docsPath:q});const n=(()=>{if(0===s.outputs.length)return[];if(1===s.outputs.length)return[r];if(Array.isArray(r))return r;throw new p(r)})();return d(s.outputs,n)}({abi:w,functionName:"query",result:[n,o]})}class $ extends b{constructor({callbackSelector:e,cause:t,data:a,extraData:r,sender:s,urls:n}){super(t.shortMessage||"An error occurred while fetching for an offchain result.",{cause:t,metaMessages:[...t.metaMessages||[],t.metaMessages?.length?"":[],"Offchain Gateway Call:",n&&["  Gateway URL(s):",...n.map(e=>`    ${k(e)}`)],`  Sender: ${s}`,`  Data: ${a}`,`  Callback selector: ${e}`,`  Extra data: ${r}`].flat(),name:"OffchainLookupError"})}}class C extends b{constructor({result:e,url:t}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${k(t)}`,`Response: ${x(e)}`],name:"OffchainLookupResponseMalformedError"})}}class v extends b{constructor({sender:e,to:t}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${t}`,`OffchainLookup sender address: ${e}`],name:"OffchainLookupSenderMismatchError"})}}e("offchainLookupSignature","0x556f1830");const A=e("offchainLookupAbiItem",{name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]});async function D({data:e,sender:t,urls:a}){let r=new Error("An unknown error occurred.");for(let s=0;s<a.length;s++){const n=a[s],o=n.includes("{data}")?"GET":"POST",c="POST"===o?{data:e,sender:t}:void 0,i="POST"===o?{"Content-Type":"application/json"}:{};try{const a=await fetch(n.replace("{sender}",t.toLowerCase()).replace("{data}",e),{body:JSON.stringify(c),headers:i,method:o});let s;if(s=a.headers.get("Content-Type")?.startsWith("application/json")?(await a.json()).data:await a.text(),!a.ok){r=new O({body:c,details:s?.error?x(s.error):a.statusText,headers:a.headers,status:a.status,url:n});continue}if(!P(s)){r=new C({result:s,url:n});continue}return s}catch(e){r=new O({body:c,details:e.message,url:n})}}throw r}}}});
